| 迭代器类别 | 支持的功能 | 

| 输入迭代器 | 只读、不写；单遍扫描，只能递增 |

| 输出迭代器 | 只写、不读；单遍扫描，只能递增 |

| 前向迭代器 | 可读写；多遍扫描，只能递增 |

| 双向迭代器 | 可读写；多遍扫描，可递增递减 |

| 随机访问迭代器 | 可读写，多遍扫描，支持全部迭代器运算 |

c++标准指明了泛型和数值算法的每个迭代器参数的最小类别，例如，find算法在一个序列上进行了一遍扫描，对元素进行只读操作，因此至少需要输入迭代器。replace函数需要一对迭代器，至少是前向迭代器。
### replace 
```c++
template<class ForwardIt, class T>
void replace(ForwardIt first, ForwardIt last,
             const T& old_value, const T& new_value)
{
    for (; first != last; ++first) {
        if (*first == old_value) {
            *first = new_value;
        }
    }
}
```
***   
输入迭代器（output iterator）：可以读取序列中的元素。一个输入迭代器必须支持 
+ 用于比较两个迭代器的相等和不相等运算符(==,!=)
+ 用于推进迭代器的前置和后置递增运算(++)
+ 用于读取元素的解引用运算符；解引用只会出现在赋值运算符的右侧
+ 箭头运算符(->)，等价(*it).member，即解引用迭代器，并提取对象的成员。

输入迭代器只用于顺序访问。对于一个输入迭代器，*it++ 保证是有效的，但递增它可能导致所有其他指向流的迭代器失效。其结果就是，不能保证输入迭代器的状态可以保存下来并用来访问元素。因此，输入迭代器只能用于单遍扫描算法。算法 find 和 accumulate 要求输入迭代器；而istream_iterator 是一种输入迭代器。

>std::accumulate
>	Defined in header &lt;numeric&gt;    
>	template&lt;class InputIt,class T &gt;   
>	T accmulate(InputIt first,Input last,T init);   
>	or   
>	template&lt;class InputIt,class T ,class BinaryOperation &gt;   
>	T accmulate(InputIt first,Input last,T init, BinaryOperation op);   

```c++
//first  version
template<class InputIt, class T>
T accumulate(InputIt first, InputIt last, T init)
{
    for (; first != last; ++first) {
        init = init + *first;
    }
    return init;
}
//second version
template<class InputIt, class T, class BinaryOperation>
T accumulate(InputIt first, InputIt last, T init, 
             BinaryOperation op)
{
    for (; first != last; ++first) {
        init = op(init, *first);
    }
    return init;
}
```   
***
输出迭代器（output iterator）：   
可以看作输入迭代器功能上的补集———只写而不读元素。输出迭代器必须支持   
+ 用于推进迭代器的前置和后置递增运算（++）
+ 解引用运算符（\*），只出现在赋值运算符的左侧（向一个已经解引用的输出迭代器赋值，就是将值写入它所指向的元素）。   

我们只能向一个输出迭代器赋值一次。类似输入迭代器，输出迭代器只能用于单遍扫描算法。用作目的位置的迭代器通常都是输出迭代器。例如，copy 函数的第三个参数就是输出迭代器。ostream_iterator 类型也是输出迭代器。   
> std:copy
> Defined in header &lt; algorithm &gt;   

```c++
//copy
template< class InputIt, class OutputIt >
OutputIt copy(InputIt first,InputIt last,OutputIt d_first);
//copy_if
template< class InputIt, class OutputIt, class UnaryPredicate >
OutputIt copy_if(InputIt first,InputIt last,Output d_first,UnaryPredicate pred);
//c++17 还有另外几个版本的define
```
***   
前向迭代器
